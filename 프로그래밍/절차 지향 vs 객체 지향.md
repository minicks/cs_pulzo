<div align="center">
    <h1>
        절차 지향 vs 객체 지향
    </h1>
</div>



<h2>
    목차
</h2>

1. [절차지향 프로그래밍](#1)
2. [객체지향 프로그래밍](#2)
3. [비교](#3)
4. [참고](#)





<div id=1>
    <h2>
        절차지향 프로그래밍(Procedural Programming)	
    </h2>
</div>

(위키 정의) **절차지향 프로그래밍** 혹은 **절차지향적 프로그래밍**이라고도 불리는 프로그래밍 패러다임의 일종으로서, 때때로 명령형 프로그래밍과 동의어로 쓰이기도 하지만, 프로시저 호출의 개념을 바탕으로 하고 있는 프로그래밍 패러다임을 의미하기도 한다.

(나무 위키 정의) 단순히 순차적인 명령 수행이 아니라 루틴, 서브루틴, 메소드, 함수 등(이를 통틀어 프로시저라고 한다.)을 이용한 프로그래밍 패러다임을 뜻함. 명령형 프로그래밍의 일종 

물이 위에서 아래로 흐르는 것처럼 **순차적인 처리**가 중요시 되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법.



**장점**

1. 객체나 클래스를 만들 필요 없이 바로 프로그램을 코딩할 수 있다.

2. 필요한 기능을 함수로 만들어 두기 때문에 같은 코드를 복사하지 않고 호출하여 사용할 수 있다.

3. 프로그램의 흐름을 쉽게 추적할 수 있다.



**단점**

1. 각 코드가 매우 유기성이 높기 때문에 수정하기가 힘들다. (새로운 데이터나 기능을 추가하기가 어려움)

2. 프로그램 전체에서 코드를 재사용 할 수가 없어 프로젝트 개발 비용과 시간이 늘어날 수 있다.

3. 디버그(오류 검사)가 어렵다.







<div id=2>
    <h2>
        객체지향 프로그래밍(Object Oriented Programming)
    </h2>
</div>

(위키 정의) 컴퓨터 프로그래밍의 패러다임 중 하나이다. 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.

(나무 위키 정의) 프로그램을 단순히 데이터와 처리 방법으로 나누는 것이 아니라, 프로그램을 수많은 '객체(object)'라는 기본 단위로 나누고 이들의 상호작용으로 서술하는 방식

객체지향이란 **실제 세계를 모델링**하여 소프트웨어를 개발하는 방법



#### 객체지향 프로그래밍의 4원칙

1. **encapsulation(캡슐화)**
   객체 내의 맴버변수에 직접적인 접근 제한하는 것을 의미.
   맴버변수를 private으로 선언하고 getter와 setter를 통해 접근하는 것을 생각하면 된다.

   

2. **abstraction(추상)**
   큰 객체를 이루는 작은 객체들이 또 그 작은 객체를 이루는 더 작은 객체들로 이루어져 있는데 이 작은 객체들을 공통된 하나의 객체로 보자는 것은 의미.
   end-user가 큰 객체를 다루기위해 큰 객체 안의 작은 객체들이 무엇으로 이루어져 있는지 다 알 필요가 없음.
   즉 객체 내부의 구조를 end-user가 알 필요없이 사용할 수 있게 해주는 것을 의미.

   

3. **inheritance(상속)**
   객체를 생성하며 공통된 특성을 가진 부모객체를 만들고 그 부모로 부터 공통된 부분을 상속받으며 추가적으로 필요한 부분을 확장시켜 자식객체를 만드는 것을 의미.

   

4. **polymorphism(다형성)**
   하나의 메소드가 다향한 형태로 동작할 수 있음을 의미.
   추상 클래스를 선언 하여 해당 클래스를 다향한 형태로 사용하거나(오버라이딩) 같은 메소드에 입력되는 인자에 다른 동작을 하는 것(오버로딩) 을 예로 들을 수 있음.



**장점**

1. 모듈화, 캡슐화로 인해 유지보수에 용이하다.

2. 객체지향적이기 때문에 현실 세계와 유사성에 의해 코드를 이해하기 쉽게 만든다.

3. 객체는 그 자체가 하나의 프로그램이기 때문에 다른 프로그램에서 재사용이 가능하다.



**단점**

1. 대부분의 객체 지향 프로그램은 속도가 상대적으로 느려지고 많은 양의 메모리를 사용하는 경향이 있다.

2. 현실 세계와 유사성에 의해 코드를 이해하기 쉽게 만드는 만큰 설계 과정에 시간이 많이 투자된다.





<div id=3>
    <h2>
        비교
    </h2>
</div>



![img](https://media.vlpt.us/images/pneuma/post/90291dcd-2392-4565-bd06-11b3e10afbe0/%E1%84%8C%E1%85%A5%E1%86%AF%E1%84%8E%E1%85%A1%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC.jpg)

![img](https://t1.daumcdn.net/cfile/tistory/997F0E435C1E055B18)

<u>절차지향 프로그래밍</u>은 **데이터**를 중심으로 함수를 구현한다. 돈을 지불하는 절차, 계산하는 절차, 제품을 받는 절차를 중점으로 함수가 구성되었다. 절차라는 단어 때문에 단순히 절차 지향 프로그래밍이 순차적으로 진행되는 것은 아니라는 점을 유의해야한다.

반면 <u>객체지향 프로그래밍</u>에서는 프로세스의 주요 **행위자**인 고객과 자판기를 객체로 설정하고 돈과 제품에 대한 관계에 따라 함수를 작성한다. 



#### **정리**

|                            | **절차지향(POP)**                                            | **객체지향(OOP)**                                            |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **영문명**                 | Procedure Oriented Programming                               | Object Oriented Programming                                  |
| **접근 방식**              | Top-Down(시스템 동작 방식을 먼저 생각,그 다음 세부 모델 디자인) | Bottom-Up(세부 모델 디자인 후 조립)                          |
| **구현 관점**              | 전체적인 기능 동작을 고려↓각 단계별로 기능을 구현            | 필요한 속성의 객체를 설계(보안성, 데이터, 함수 등)↓각 객체의 상호작용(절차)을 설계 |
| **구성 요소**              | 함수                                                         | 객체                                                         |
| **접근 제어**              | 없음(전부 Public)                                            | Public, Protected, Private                                   |
| **오버로딩, 다형성**       | 불가능                                                       | 함수, 생성자, 연산자 등을 오버로딩 가능                      |
| **상속**                   | 불가능                                                       | 가능(Public, Protected, Private)                             |
| **보안성**                 | 낮음                                                         | 높음                                                         |
| **데이터 공유**            | 모든 함수가 공유 가능                                        | 객체 간 멤버함수로만 공유                                    |
| **Friend 함수**            | 없음                                                         | C++에 있음                                                   |
| **가상 클래스, 가상 함수** | 없음                                                         | 상속 개념 아래 존재함                                        |
| **예시 언어**              | C, Visual Basic, Fortran, Pascal                             | C++, Java, VB.NET, C#, Python                                |
| **장점**                   | 컴퓨터 눈높이로 구성된 문법으로 바닥부터 입맛대로 설계하기 좋습니다. | 인간 눈높이에서 구조를 파악하기가 좋습니다. 또한 객체 기능을 제공하므로 코드를 절약할 수 있습니다. |
| **단점**                   | 프로젝트가 커질 시 구조가 복잡해지고 중복 코드를 작성할 수도 있습니다. | 제공된 객체 기능에서 발생하는 오버헤드를 최적화 할 수 없다면 상대적으로 느려집니다. |
| **용도**                   | 자원이 한정되어 있거나 바닥부터 설계할 필요가 있는 프로젝트에 사용됩니다. | 규모가 크고 협업이 잦으며 생산성이 중시되는 프로젝트에 사용됩니다. |





<div id=4>
    <h2>
        참고
    </h2>
</div>

- 나무위키 절차지향

https://namu.wiki/w/%EC%A0%88%EC%B0%A8%EC%A0%81%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D?from=%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D



- 위키백과 절차지향

https://ko.wikipedia.org/wiki/%EC%A0%88%EC%B0%A8%EC%A0%81_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D



https://usefultoknow.tistory.com/entry/%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5Procedural-Programming-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5Object-Oriented-Programming-%EC%9E%A5%EB%8B%A8%EC%A0%90-%EB%B0%8F-%EC%B0%A8%EC%9D%B4%EC%A0%90

http://www.incodom.kr/%EC%A0%88%EC%B0%A8_%EC%A7%80%ED%96%A5
