# 동기화 도구

- 경쟁 상황을 피하고자 공유 데이터에 대한 액세스를 제어하는 도구

- 경쟁 상황(race condition) : 동시에 여러 개의 프로세스가 동일한 자료를 접근하여 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황

## 임계구역(critical section)

- 하나 이상의 다른 프로세스와 공유하는 데이터에 접근하고 갱신할 수 있는 코드 부분
- 동시에 두 프로세스가 그들의 임계구역 안에서 실행할 수 없음

```java
// 전형적인 프로세스의 일반적인 구조
while (true) {
	// entry section

	// critical section

	// exit section

	// remainder section
}
```

- 진입 구역(entry section) - 임계구역에 진입하기 위해 진입 허가 요청을 하는 코드 부분
- 퇴출 구역(exit section) - 임계구역에서 나오는 부분
- 나머지 구역(remainder section) - 나머지 코드들의 총칭
- 임계구역 문제 : 프로세스들이 데이터를 협력적으로 공유하기 위해 자신들의 활동을 동기화할 때 사용할 수 있는 프로토콜을 설계하는 것
- 임계구역 문제 해결안의 요구조건

  - 상호 배제(**mut**ual **ex**clusion) : 하나의 프로세스가 자신의 임계구역에서 실행될 때, 다른 프로세스들은 각자의 임계구역에서 실행될 수 없음
  - 진행(progress) : 자신의 임계구역에서 실행되는 프로세스가 없다면, 누가 임계구역에 진입할 수 있는지를 결정할 수 있음
  - 한정된 대기(bounded waiting) : 임계구역에 진입 요청을 한 후부터 허용될 때까지 다른 프로세스들이 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 함

- 운영체제 내에서 임계구역을 다루기 위한 접근법
  - 선점형 커널
    - 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용
    - 서로 다른 프로세스가 동시에 커널 모드에 있을 수 있음
    - 커널 모드 프로세스가 대기 중인 프로세스에 처리기를 양도하기 전까지 오랫동안 실행할 위험이 적음
    - 응답이 민첩할 수 있음
    - 실시간 프로세스가 현재 커널에서 실행 중인 프로세스를 선정할 수 있기 때문에 실시간 프로그래밍에 적당
  - 비선점형 커널
    - 커널 모드에서 수행되는 프로세스의 선점을 허용하지 않음
    - 커널 모드 프로세서를 커널을 빠져나가거나 봉쇄, 자발적으로 CPU의 제어를 양보할 때까지 수행
    - 커널 안에서 실행 중인 프로세스는 하나밖에 없으므로 경쟁 조건을 염려하지 않아도 됨

## Peterson의 해결안

- 임계구역에 대한 **고전적**인 **소프트웨어 기반** 해결책
- 현대 컴퓨터 구조에서 올바르게 실행됨을 보장하지는 않음
- 임계구역 문제를 해결하기 위한 좋은 알고리즘적인 설명 제공
- 요구 조건을 중점으로 다루는 소프트웨어를 설계하는 데 필요한 복잡성을 잘 설명
- 두 프로세스가 두 개의 데이터 항목을 공유하도록 하여 해결

```java
int turn; // 임계구역으로 진입할 순번
boolean flag[2]; // 프로세스가 임계구역으로 진입할 준비가 된 상태
```

```java
// Peterson의 해결안에서 프로세스의 구조
while (true) {
	flag[i] = true;
    turn = j;
    while (flag[j] && turn == j);

    // critical section

    flag[i] = false;

    // remainder section
}
```

## 하드웨어 지원

### 메모리 장벽

- 메모리 모델 : 컴퓨터 아키텍처가 응용 프로그램에게 제공하는 메모리 접근 시 보장되는 사항을 결정한 방식
- 강한 순서 : 프로세서의 메모리 변경 결과가 다른 모든 프로세서에 즉시 보임
- 약한 순서 : 프로세서의 메모리 변경 결과가 즉시 보이지 않음
- 메모리의 모든 변경 사항을 다른 모든 프로세서로 전파하는 명령어 제공
- 다른 프로세서에서 실행 중인 스레드에 메모리 변경 사항이 보이는 것을 보장

### 하드웨어 명령어

- 한 워드의 내용을 검사, 변경, 두 워드의 내용을 원자적으로 교환하는 명령어 제공

### 원자적 변수

- 정수, 부울과 같은 기본 데이터 유형에 대한 원자적 연산 제공

## Mutex Locks

- 하드웨어 기반 해결책은 복잡하고 응용 프로그래머가 사용할 수 없음
- 임계구역을 보호하고 경쟁조건을 방지
- 프로세스는 임계구역에 들어가기 전에 락을 획득, 임계구역을 빠져나올 때 락을 반환
- 스핀락(spinlock) : 락을 사용할 수 있을 때까지 프로세스가 회전

```java
// Mutex 락을 사용한 임계구역 문제 해결책
while (true) {
    // acquire lock

    // critical section

    // release lock

    // remainder section
}
```

```java
// acquire()
acquire() {
    while (!available); // busy wait

    available = false;
}

// release()
release() {
    available = true;
}
```

- busy wait(바쁜 대기) - 프로세스가 임계구역에 있는 동안 임계구역에 들어가기를 원하는 다른 프로세스들은 반복문을 계속 실행
- 문맥 교환이 필요하지 않음

## 세마포어(semaphore)

- 세마포어 S는 정수 변수로서, 초기화를 제외하고 wait()와 signal()로만 접근

```java
// wait() P (Proberen 검사하다)
wait(S) {
    while (S <= 0); // busy wait

    S--;
}

// signal() V (verhogen 증가하다)
signal(S) {
    s++;
}
```

- 카운팅 세마포어 : 제한 없는 영역(domain)
- 이진 세마포어 : 0 or 1, mutex 락과 유사
- 바쁜 대기 대신에 일시 중지
- 프로세스를 대기 큐에 넣고 프로세스의 상태를 대기 상태로 전환
- CPU 스케줄러에 의해 제어
- 일시 중지된 프로세서는 다른 프로세스가 signal() 연산을 실행하면 wakeup() 연산에 의해 재시작
- 프로세서의 상태를 대기상태에서 준비완료 상태로 변경, 준비 완료 큐에 넣음

```java
// semaphore의 정의
typedef struct {
    int value; // 세마포어의 값
    struct process *list; // 대기 중인 프로세스 큐
} semaphore;
```

```java
// wait()
wait(semaphore *S) {
    S->value--;
    if (S->value < 0) {
        add this process to S->list;
        sleep(); // 해당 프로세스를 일시 중지
    }
}

// signal()
signal(semaphore *S) {
    S->value++;
    if (S->value <= 0) {
        remove a process P from S->list;
        wakeup(P); // 일시 중지된 프로세스 P를 재개
    }
}
```

- 바쁜 대기를 완전하게 제거하지 못 함
- 바쁜 대기가 진입 코드에서 응용 프로그램의 임계구역으로 이동

## 모니터

- 간단한 동기화 도구를 통합한 고급 언어 구조물 중 하나
- 모니터 내부에서 상호 배제가 보장되는 프로그래머가 정의한 일련의 연산자 집합을 포함하는 ADT
- ADT(abstract data type, 추상화된 데이터 형) : 데이터와 이 데이터를 조작하는 함수들의 집합
- 모니터 인스턴스 상태, 변수들을 조작하는 프로시저 또는 함수들의 본체
- 다른 프로세스에서 접근할 수 없음

- 동기화를 위해 하나 이상의 condition 이라는 구조물을 이용
- wait()와 signal() 연산으로만 condition 형 변수를 호출 가능

## Reference

Silberschatz, A., Galvin, P. B., Gagne, G. (2020). Operating System Concepts 10th Edition.
